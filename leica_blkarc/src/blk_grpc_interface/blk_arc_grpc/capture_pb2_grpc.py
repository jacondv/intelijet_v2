# Generated by the gRPC Python protocol compiler plugin. DO NOT EDIT!
"""Client and server classes corresponding to protobuf-defined services."""
import grpc

from blk_arc_grpc import capture_pb2 as blk__arc__grpc_dot_capture__pb2
from google.protobuf import empty_pb2 as google_dot_protobuf_dot_empty__pb2


class CaptureStub(object):
    """*
    This service contains all the methods related to a capture.
    It includes both live data streaming of an ongoing capture and streaming of past scans saved on disk.

    NOTE: All timestamps in this service are based on the head assembly clock unless otherwise specified.
    To convert this to a UTC timestamp, please refer to the `Clock` service.
    """

    def __init__(self, channel):
        """Constructor.

        Args:
            channel: A grpc.Channel.
        """
        self.StartCapture = channel.unary_unary(
                '/api.blk.Capture/StartCapture',
                request_serializer=google_dot_protobuf_dot_empty__pb2.Empty.SerializeToString,
                response_deserializer=blk__arc__grpc_dot_capture__pb2.StartCaptureResponse.FromString,
                )
        self.PauseCapture = channel.unary_unary(
                '/api.blk.Capture/PauseCapture',
                request_serializer=google_dot_protobuf_dot_empty__pb2.Empty.SerializeToString,
                response_deserializer=blk__arc__grpc_dot_capture__pb2.PauseCaptureResponse.FromString,
                )
        self.ResumeCapture = channel.unary_unary(
                '/api.blk.Capture/ResumeCapture',
                request_serializer=google_dot_protobuf_dot_empty__pb2.Empty.SerializeToString,
                response_deserializer=blk__arc__grpc_dot_capture__pb2.ResumeCaptureResponse.FromString,
                )
        self.StopCapture = channel.unary_unary(
                '/api.blk.Capture/StopCapture',
                request_serializer=google_dot_protobuf_dot_empty__pb2.Empty.SerializeToString,
                response_deserializer=blk__arc__grpc_dot_capture__pb2.StopCaptureResponse.FromString,
                )
        self.GetCaptureStatus = channel.unary_unary(
                '/api.blk.Capture/GetCaptureStatus',
                request_serializer=google_dot_protobuf_dot_empty__pb2.Empty.SerializeToString,
                response_deserializer=blk__arc__grpc_dot_capture__pb2.CaptureStatusResponse.FromString,
                )
        self.StreamLiveCapture = channel.unary_stream(
                '/api.blk.Capture/StreamLiveCapture',
                request_serializer=blk__arc__grpc_dot_capture__pb2.LiveStreamRequest.SerializeToString,
                response_deserializer=blk__arc__grpc_dot_capture__pb2.CaptureStreamMessage.FromString,
                )
        self.StreamSavedCapture = channel.unary_stream(
                '/api.blk.Capture/StreamSavedCapture',
                request_serializer=blk__arc__grpc_dot_capture__pb2.SavedStreamRequest.SerializeToString,
                response_deserializer=blk__arc__grpc_dot_capture__pb2.CaptureStreamMessage.FromString,
                )


class CaptureServicer(object):
    """*
    This service contains all the methods related to a capture.
    It includes both live data streaming of an ongoing capture and streaming of past scans saved on disk.

    NOTE: All timestamps in this service are based on the head assembly clock unless otherwise specified.
    To convert this to a UTC timestamp, please refer to the `Clock` service.
    """

    def StartCapture(self, request, context):
        """*
        Starts a new capture and returns the scan ID and the starting time immediately (non-blocking).
        The capture will then be set to a `STARTING` state until SLAM initialises.

        Error Codes:
        - gRPC status 2 (UNKNOWN): If the capture cannot start for any other reason.
        - gRPC status 9 (FAILED_PRECONDITION): If a capture is already in progress.
        - gRPC status 13 (INTERNAL): If the device is not ready to start a capture due to faulty or missing hardware.

        Authorization Scopes:
        - `capture`
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def PauseCapture(self, request, context):
        """*
        Pause started capture.
        This only put a mark to data file, does not physically interrupt the scan

        Error Codes:
        - gRPC status 9 (FAILED_PRECONDITION): If a capture is not in progress.

        Authorization Scopes:
        - `capture`
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def ResumeCapture(self, request, context):
        """*
        Resume paused capture.
        This only put a mark to data file, does not physically start the scan

        Error Codes:
        - gRPC status 9 (FAILED_PRECONDITION): If a capture is not in progress or is not paused.

        Authorization Scopes:
        - `capture`
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def StopCapture(self, request, context):
        """*
        Stops the current capture and returns information about the same.

        Error Codes:
        - gRPC status 9 (FAILED_PRECONDITION): If there is no capture in progress.
        - gRPC status 14 (UNAVAILABLE): If the device did not respond or cannot perform the action at this point in time. The call shall be retried.

        Authorization Scopes:
        - `capture`
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def GetCaptureStatus(self, request, context):
        """*
        Gets the current capture state. This may be called at any point in time, even if no capture is ongoing.

        Authorization Scopes:
        - `capture`
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def StreamLiveCapture(self, request, context):
        """*
        Streams the requested messages related to an ongoing capture. This method will not start a capture by itself.

        Error Codes:
        - gRPC status 3 (INVALID_ARGUMENT): If the request cannot be fulfilled by the system due to the arguments provided. The call could be retried with different arguments.
        - gRPC status 7 (PERMISSION_DENIED): If the caller does not have the adequate scopes for the operation requested.
        - gRPC status 9 (FAILED_PRECONDITION): If there is no ongoing capture. In this context, a `STARTING` capture is treated as an ongoing capture.

        Authorization Scopes:
        - `capture`
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def StreamSavedCapture(self, request, context):
        """*
        Streams all requested messages related to a saved capture with the specified `scan_id`. In contrast to the `StreamLiveCapture` method, no capture should be ongoing.
        The messages sent on this stream will have the exact same format as a live scan would produce.

        Error Codes:
        - gRPC status 3 (INVALID_ARGUMENT): If the request cannot be fulfilled by the system due to the arguments provided. The call could be retried with different arguments. This would be the case, for example, if `playback_speed` is set to 0.
        - gRPC status 5 (NOT_FOUND): If the `scan_id` provided cannot be found.
        - gRPC status 7 (PERMISSION_DENIED): If the caller does not have the adequate scopes for the operation requested.
        - gRPC status 9 (FAILED_PRECONDITION): If there is an ongoing capture. The device must be in an `IDLE` state.
        - gRPC status 11 (OUT_OF_RANGE): If the `timeline_start` specified is greater than or equal to the `timeline_end`.

        Authorization Scopes:
        - `capture`
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')


def add_CaptureServicer_to_server(servicer, server):
    rpc_method_handlers = {
            'StartCapture': grpc.unary_unary_rpc_method_handler(
                    servicer.StartCapture,
                    request_deserializer=google_dot_protobuf_dot_empty__pb2.Empty.FromString,
                    response_serializer=blk__arc__grpc_dot_capture__pb2.StartCaptureResponse.SerializeToString,
            ),
            'PauseCapture': grpc.unary_unary_rpc_method_handler(
                    servicer.PauseCapture,
                    request_deserializer=google_dot_protobuf_dot_empty__pb2.Empty.FromString,
                    response_serializer=blk__arc__grpc_dot_capture__pb2.PauseCaptureResponse.SerializeToString,
            ),
            'ResumeCapture': grpc.unary_unary_rpc_method_handler(
                    servicer.ResumeCapture,
                    request_deserializer=google_dot_protobuf_dot_empty__pb2.Empty.FromString,
                    response_serializer=blk__arc__grpc_dot_capture__pb2.ResumeCaptureResponse.SerializeToString,
            ),
            'StopCapture': grpc.unary_unary_rpc_method_handler(
                    servicer.StopCapture,
                    request_deserializer=google_dot_protobuf_dot_empty__pb2.Empty.FromString,
                    response_serializer=blk__arc__grpc_dot_capture__pb2.StopCaptureResponse.SerializeToString,
            ),
            'GetCaptureStatus': grpc.unary_unary_rpc_method_handler(
                    servicer.GetCaptureStatus,
                    request_deserializer=google_dot_protobuf_dot_empty__pb2.Empty.FromString,
                    response_serializer=blk__arc__grpc_dot_capture__pb2.CaptureStatusResponse.SerializeToString,
            ),
            'StreamLiveCapture': grpc.unary_stream_rpc_method_handler(
                    servicer.StreamLiveCapture,
                    request_deserializer=blk__arc__grpc_dot_capture__pb2.LiveStreamRequest.FromString,
                    response_serializer=blk__arc__grpc_dot_capture__pb2.CaptureStreamMessage.SerializeToString,
            ),
            'StreamSavedCapture': grpc.unary_stream_rpc_method_handler(
                    servicer.StreamSavedCapture,
                    request_deserializer=blk__arc__grpc_dot_capture__pb2.SavedStreamRequest.FromString,
                    response_serializer=blk__arc__grpc_dot_capture__pb2.CaptureStreamMessage.SerializeToString,
            ),
    }
    generic_handler = grpc.method_handlers_generic_handler(
            'api.blk.Capture', rpc_method_handlers)
    server.add_generic_rpc_handlers((generic_handler,))


 # This class is part of an EXPERIMENTAL API.
class Capture(object):
    """*
    This service contains all the methods related to a capture.
    It includes both live data streaming of an ongoing capture and streaming of past scans saved on disk.

    NOTE: All timestamps in this service are based on the head assembly clock unless otherwise specified.
    To convert this to a UTC timestamp, please refer to the `Clock` service.
    """

    @staticmethod
    def StartCapture(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(request, target, '/api.blk.Capture/StartCapture',
            google_dot_protobuf_dot_empty__pb2.Empty.SerializeToString,
            blk__arc__grpc_dot_capture__pb2.StartCaptureResponse.FromString,
            options, channel_credentials,
            insecure, call_credentials, compression, wait_for_ready, timeout, metadata)

    @staticmethod
    def PauseCapture(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(request, target, '/api.blk.Capture/PauseCapture',
            google_dot_protobuf_dot_empty__pb2.Empty.SerializeToString,
            blk__arc__grpc_dot_capture__pb2.PauseCaptureResponse.FromString,
            options, channel_credentials,
            insecure, call_credentials, compression, wait_for_ready, timeout, metadata)

    @staticmethod
    def ResumeCapture(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(request, target, '/api.blk.Capture/ResumeCapture',
            google_dot_protobuf_dot_empty__pb2.Empty.SerializeToString,
            blk__arc__grpc_dot_capture__pb2.ResumeCaptureResponse.FromString,
            options, channel_credentials,
            insecure, call_credentials, compression, wait_for_ready, timeout, metadata)

    @staticmethod
    def StopCapture(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(request, target, '/api.blk.Capture/StopCapture',
            google_dot_protobuf_dot_empty__pb2.Empty.SerializeToString,
            blk__arc__grpc_dot_capture__pb2.StopCaptureResponse.FromString,
            options, channel_credentials,
            insecure, call_credentials, compression, wait_for_ready, timeout, metadata)

    @staticmethod
    def GetCaptureStatus(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(request, target, '/api.blk.Capture/GetCaptureStatus',
            google_dot_protobuf_dot_empty__pb2.Empty.SerializeToString,
            blk__arc__grpc_dot_capture__pb2.CaptureStatusResponse.FromString,
            options, channel_credentials,
            insecure, call_credentials, compression, wait_for_ready, timeout, metadata)

    @staticmethod
    def StreamLiveCapture(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_stream(request, target, '/api.blk.Capture/StreamLiveCapture',
            blk__arc__grpc_dot_capture__pb2.LiveStreamRequest.SerializeToString,
            blk__arc__grpc_dot_capture__pb2.CaptureStreamMessage.FromString,
            options, channel_credentials,
            insecure, call_credentials, compression, wait_for_ready, timeout, metadata)

    @staticmethod
    def StreamSavedCapture(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_stream(request, target, '/api.blk.Capture/StreamSavedCapture',
            blk__arc__grpc_dot_capture__pb2.SavedStreamRequest.SerializeToString,
            blk__arc__grpc_dot_capture__pb2.CaptureStreamMessage.FromString,
            options, channel_credentials,
            insecure, call_credentials, compression, wait_for_ready, timeout, metadata)
