# Generated by the gRPC Python protocol compiler plugin. DO NOT EDIT!
"""Client and server classes corresponding to protobuf-defined services."""
import grpc

from blk_arc_grpc import masking_pb2 as blk__arc__grpc_dot_masking__pb2


class MaskingStub(object):
    """*
    The masking service that can be used to manage SLAM camera and Lidar masks
    that get applied and saved into scans.

    The capture application always starts up with empty masks. This means that
    after a reboot or capture application crash, the last configured mask is
    lost.
    """

    def __init__(self, channel):
        """Constructor.

        Args:
            channel: A grpc.Channel.
        """
        self.ResetMask = channel.unary_unary(
                '/api.blk.Masking/ResetMask',
                request_serializer=blk__arc__grpc_dot_masking__pb2.MaskRequest.SerializeToString,
                response_deserializer=blk__arc__grpc_dot_masking__pb2.MaskResetResponse.FromString,
                )
        self.GetMask = channel.unary_unary(
                '/api.blk.Masking/GetMask',
                request_serializer=blk__arc__grpc_dot_masking__pb2.MaskRequest.SerializeToString,
                response_deserializer=blk__arc__grpc_dot_masking__pb2.MaskDescription.FromString,
                )
        self.SetMask = channel.unary_unary(
                '/api.blk.Masking/SetMask',
                request_serializer=blk__arc__grpc_dot_masking__pb2.MaskDescription.SerializeToString,
                response_deserializer=blk__arc__grpc_dot_masking__pb2.MaskSetResponse.FromString,
                )


class MaskingServicer(object):
    """*
    The masking service that can be used to manage SLAM camera and Lidar masks
    that get applied and saved into scans.

    The capture application always starts up with empty masks. This means that
    after a reboot or capture application crash, the last configured mask is
    lost.
    """

    def ResetMask(self, request, context):
        """*
        Reset the mask of a certain type. Afterwards the mask is "all clear",
        i.e. no masking is taking place for the specific type.

        Authorization Scopes:
        - `masking`
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def GetMask(self, request, context):
        """*
        Get the mask of a certain type currently configured.

        Before any mask is set, this will return an "all clear" mask of the size
        expected for the relevant type.

        Error Codes:
        - gRPC status 7 (PERMISSION_DENIED): If the caller token does not have access to the necessary scopes for the operation.
        - gRPC status 16 (UNAUTHENTICATED): If the caller has not provided any Authentication Token in the headers.

        Authorization Scopes:
        - `masking`
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def SetMask(self, request, context):
        """*
        Set the mask of a certain type.

        This mask will be set and applied to any future scan. The mask is lost
        on capture application restart and reboot.

        Error Codes:
        - gRPC status 7 (PERMISSION_DENIED): If the caller token does not have access to the necessary scopes for the operation.
        - gRPC status 3 (INVALID_ARGUMENT): If the height or width of the mask
        type does not meet the requirements for the sensor.
        - gRPC status 16 (UNAUTHENTICATED): If the caller has not provided any Authentication Token in the headers.

        Authorization Scopes:
        - `masking`
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')


def add_MaskingServicer_to_server(servicer, server):
    rpc_method_handlers = {
            'ResetMask': grpc.unary_unary_rpc_method_handler(
                    servicer.ResetMask,
                    request_deserializer=blk__arc__grpc_dot_masking__pb2.MaskRequest.FromString,
                    response_serializer=blk__arc__grpc_dot_masking__pb2.MaskResetResponse.SerializeToString,
            ),
            'GetMask': grpc.unary_unary_rpc_method_handler(
                    servicer.GetMask,
                    request_deserializer=blk__arc__grpc_dot_masking__pb2.MaskRequest.FromString,
                    response_serializer=blk__arc__grpc_dot_masking__pb2.MaskDescription.SerializeToString,
            ),
            'SetMask': grpc.unary_unary_rpc_method_handler(
                    servicer.SetMask,
                    request_deserializer=blk__arc__grpc_dot_masking__pb2.MaskDescription.FromString,
                    response_serializer=blk__arc__grpc_dot_masking__pb2.MaskSetResponse.SerializeToString,
            ),
    }
    generic_handler = grpc.method_handlers_generic_handler(
            'api.blk.Masking', rpc_method_handlers)
    server.add_generic_rpc_handlers((generic_handler,))


 # This class is part of an EXPERIMENTAL API.
class Masking(object):
    """*
    The masking service that can be used to manage SLAM camera and Lidar masks
    that get applied and saved into scans.

    The capture application always starts up with empty masks. This means that
    after a reboot or capture application crash, the last configured mask is
    lost.
    """

    @staticmethod
    def ResetMask(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(request, target, '/api.blk.Masking/ResetMask',
            blk__arc__grpc_dot_masking__pb2.MaskRequest.SerializeToString,
            blk__arc__grpc_dot_masking__pb2.MaskResetResponse.FromString,
            options, channel_credentials,
            insecure, call_credentials, compression, wait_for_ready, timeout, metadata)

    @staticmethod
    def GetMask(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(request, target, '/api.blk.Masking/GetMask',
            blk__arc__grpc_dot_masking__pb2.MaskRequest.SerializeToString,
            blk__arc__grpc_dot_masking__pb2.MaskDescription.FromString,
            options, channel_credentials,
            insecure, call_credentials, compression, wait_for_ready, timeout, metadata)

    @staticmethod
    def SetMask(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(request, target, '/api.blk.Masking/SetMask',
            blk__arc__grpc_dot_masking__pb2.MaskDescription.SerializeToString,
            blk__arc__grpc_dot_masking__pb2.MaskSetResponse.FromString,
            options, channel_credentials,
            insecure, call_credentials, compression, wait_for_ready, timeout, metadata)
